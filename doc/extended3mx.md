## extended: pointcloud resource json
```
{
	neb::CJsonObject oJson;
	oJson.Add("type", resource.type);
	oJson.Add("format", resource.format);
	oJson.Add("id", resource.id);
	if (resource.type == "geometryBuffer")
	{
		if (resource.format == "ctm")
		{
			oJson.Add("texture", resource.texture);
		}
		else if (resource.format == "xyz")	// extended: format xyz to store pointcloud geometry
		{
			oJson.Add("pointSize", resource.pointSize);	// extended: point size for viewer
		}

		oJson.AddEmptySubArray("bbMin");
		oJson["bbMin"].Add(resource.bb.xMin());
		oJson["bbMin"].Add(resource.bb.yMin());
		oJson["bbMin"].Add(resource.bb.zMin());

		oJson.AddEmptySubArray("bbMax");
		oJson["bbMax"].Add(resource.bb.xMax());
		oJson["bbMax"].Add(resource.bb.yMax());
		oJson["bbMax"].Add(resource.bb.zMax());
	}
	oJson.Add("size", resource.bufferData.size());
	return oJson;
}
```

## extended: pointcloud resource binary
```
{
	std::vector<float> aVertices;
	std::vector<char> aColors;

	osg::Array* va = geometry->getVertexArray();
	int vec_size = 0;
	if (va)
	{
		osg::Vec3Array* v3f = (osg::Vec3Array*)va;
		vec_size = v3f->size();
		for (int vidx = 0; vidx < vec_size; vidx++)
		{
			osg::Vec3f point = v3f->at(vidx);
			aVertices.push_back(point.x());
			aVertices.push_back(point.y());
			aVertices.push_back(point.z());
		}
	}

	// color
	osg::Array* ca = geometry->getColorArray();
	int color_size;
	if (ca)
	{
		osg::Vec4Array* v4f = (osg::Vec4Array*)ca;
		color_size = v4f->size();
		for (int vidx = 0; vidx < color_size; vidx++)
		{
			osg::Vec4f point = v4f->at(vidx);
			aColors.push_back(char(point.x() * 255));
			aColors.push_back(char(point.y() * 255));
			aColors.push_back(char(point.z() * 255));
			aColors.push_back(char(point.w() * 255));
		}
	}

	if (vec_size == 0) {
		return;
	}
	if (vec_size != color_size) {
		return;
	}

	bufferData.insert(bufferData.end(), (char*)&vec_size, (char*)&vec_size + 4);	// extended: number of points
	bufferData.insert(bufferData.end(), (char*)aVertices.data(), (char*)aVertices.data() + sizeof(float) * aVertices.size());	// xyz in float
	bufferData.insert(bufferData.end(), (char*)aColors.data(), (char*)aColors.data() + sizeof(char) * aColors.size()); // rgb in byte
}
```

## extended: 3mx offset
```
{
	"3mxVersion":	1,
	"name":	"Root",
	"description":	"Generated by ProjSEED/lodToolkit, copyright <a href='https://github.com/ProjSEED/lodToolkit' target='_blank'>ProjSEED</a>.",
	"logo":	"logo.png",
	"sceneOptions":	[{
			"navigationMode":	"ORBIT"
		}],
	"layers":	[{
			"type":	"modelPyramid",
			"id":	"model0",
			"name":	"Root",
			"description":	"Converted by ProjSEED/lodToolkit, copyright <a href='https://github.com/ProjSEED/lodToolkit' target='_blank'>ProjSEED</a>.",
			"SRS":	"",
			"SRSOrigin":	[0.000000, 0.000000, 0.000000],
			"offset":	[-101.165941, -280.486164, -15.386151], // extended: offset to handle large pointcloud xyz coord
			"root":	"Data/Root.3mxb"
		}]
}
```